/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.bensivo.otel.tracing.demo.basic;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;

import io.opentelemetry.api.trace.Span;
import io.opentelemetry.context.Context;
import io.opentelemetry.sdk.common.CompletableResultCode;
import com.bensivo.otel.tracing.OtelTracer;

public class App {
    public static void main(String[] args) throws InterruptedException, ExecutionException {
        OtelTracer tracer = new OtelTracer("java-tracing-demo-basic", "0.0.0");
        tracer.initialize();

        System.out.println("Starting pipeline");
        Span pipelineSpan = tracer.span("pipeline");
        Context pipelineContext = tracer.context(pipelineSpan);

        System.out.println("Starting job-a");
        Span jobASpan = tracer.span("job-a", pipelineContext);
        TimeUnit.SECONDS.sleep(1);
        jobASpan.end();

        System.out.println("Starting job-b");
        Span jobBSpan = tracer.span("job-b", pipelineContext);
        TimeUnit.SECONDS.sleep(1);
        jobBSpan.end();

        System.out.println("Starting job-c");
        Span jobCSpan = tracer.span("job-c", pipelineContext);
        Context jobCContext = tracer.context(jobCSpan, pipelineContext);

        // Within job c, run 3 tasks in parallel using a ThreadPool Executor
        ExecutorService executor = Executors.newCachedThreadPool();
        List<Callable<Boolean>> tasks = new ArrayList<>();
        for (int i = 0; i < 3; i++) {
            Callable<Boolean> c = new Callable<Boolean>() {
                @Override
                public Boolean call() throws InterruptedException{
                    System.out.println("Starting task");
                    Span taskSpan = tracer.span("task", jobCContext);
                    TimeUnit.SECONDS.sleep(1);
                    taskSpan.end();
                    return true;
                }
            };
            tasks.add(c);
        }
        
        // Invoke all 3 tasks, and wait for the results
        List<Future<Boolean>> results = executor.invokeAll(tasks);
        for (Future<Boolean> result : results) {
            result.get();
        }
        executor.shutdown();

        jobCSpan.end();
        pipelineSpan.end();

        System.out.println("Flushing");
        CompletableResultCode res = tracer.flush();
        res.join(180, TimeUnit.SECONDS);
    }
}
